<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Hashtag Counter — last 24h</title>
  <style>
    :root { --bg:#0b1220; --card:#121a2b; --text:#e8eefb; --muted:#9fb0ce; --accent:#7aa2ff; }
    * { box-sizing: border-box; }
    body { margin:0; background:var(--bg); color:var(--text); font: 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    .wrap { max-width: 820px; margin: 32px auto; padding: 0 16px; }
    .card {
      background: var(--card);
      border-radius: 16px; padding: 18px; box-shadow: 0 6px 18px rgba(0,0,0,.24);
      border: 1px solid rgba(255,255,255,.06);
    }
    h1 { margin: 0 0 8px; font-size: 20px; }
    p.muted { color: var(--muted); margin-top: 6px; }
    .row { display:flex; gap:12px; flex-wrap:wrap; align-items: center; }
    input[type="text"] {
      background: #0e1626; border: 1px solid rgba(255,255,255,.12); color: var(--text);
      border-radius: 12px; padding: 10px 12px; min-width: 220px; outline: none;
    }
    label { color: var(--muted); display:flex; align-items:center; gap:6px; }
    button {
      background: var(--accent); color: #0b1220; border: 0; border-radius: 12px;
      padding: 10px 14px; font-weight: 700; cursor: pointer;
    }
    .metric {
      display:flex; align-items: baseline; gap: 10px; margin-top: 12px;
    }
    .metric .value { font-size: 44px; font-weight: 800; letter-spacing: -0.5px; }
    .metric .label { color: var(--muted); }
    .status { color: var(--muted); margin-top: 6px; min-height: 1.2em; }
    canvas { width: 100%; height: 160px; display: block; }
    .footer { color: var(--muted); text-align:center; margin-top: 18px; font-size: 12px; }
    .badge { background:#0e1626; border:1px solid rgba(255,255,255,.12); padding:2px 8px; border-radius:999px; font-size:12px; color:var(--muted); }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <h1>Hashtag Counter — last 24h</h1>
      <p class="muted">Counts posts using X/Twitter’s <span class="badge">recent counts</span> endpoint over the last 24 hours.</p>

      <div class="row" style="margin-top:12px">
        <input id="q" type="text" value="#zec" autocomplete="off" />
        <label title="Exclude retweets from the count">
          <input id="noRT" type="checkbox" />
          Exclude retweets
        </label>
        <button id="go">Refresh</button>
        <span class="badge" id="updated">—</span>
      </div>

      <div class="metric">
        <div class="value" id="total">—</div>
        <div class="label">mentions in the past 24h</div>
      </div>
      <div class="status" id="status"></div>

      <div style="margin-top:10px">
        <canvas id="chart" width="800" height="160" aria-label="Hourly sparkline"></canvas>
      </div>
    </div>

    <div class="footer">
      Edit the query and press Refresh. Examples: <code>#zec</code>, <code>$ZEC</code>, <code>#zec OR $ZEC</code>.
    </div>
  </div>
<script>
  const els = {
    q: document.getElementById('q'),
    noRT: document.getElementById('noRT'),
    go: document.getElementById('go'),
    total: document.getElementById('total'),
    status: document.getElementById('status'),
    updated: document.getElementById('updated'),
    canvas: document.getElementById('chart'),
  };

  let nextTimer = null;
  let lastGood = null; // keep last successful payload

  function scheduleNext(ms) {
    if (nextTimer) clearTimeout(nextTimer);
    nextTimer = setTimeout(fetchCounts, Math.max(ms, 1000));
  }

  async function fetchCounts() {
    const query = els.q.value.trim();
    if (!query) return;

    const params = new URLSearchParams({
      q: query,
      retweets: els.noRT.checked ? '0' : '1',
      granularity: 'hour'
    });

    els.status.textContent = 'Loading…';
    try {
      const r = await fetch(`/api/x-count?${params}`);
      const j = await r.json();

      if (!r.ok) {
        els.status.textContent = j?.error ? `Error: ${j.error}` : `HTTP ${r.status}`;
        // Try again in 5 minutes if unknown error
        scheduleNext(5 * 60 * 1000);
        return;
      }

      // Handle rate limit: keep showing last known total and sleep until reset
      if (j?.retry_after_ms !== undefined) {
        if (lastGood?.total != null) els.total.textContent = lastGood.total.toLocaleString();
        const resetAt = j.retry_at ? new Date(j.retry_at) : new Date(Date.now() + j.retry_after_ms);
        els.status.textContent = `Rate-limited. Next refresh @ ${resetAt.toLocaleTimeString()}`;
        scheduleNext((resetAt - new Date()) + 1500);
        return;
      }

      // Success
      lastGood = j;
      els.total.textContent = (typeof j.total === 'number') ? j.total.toLocaleString() : '—';
      const rl = j?.rate_limit;
      const rlStr = rl ? `Rate limit: ${rl.remaining ?? '?'} / ${rl.limit ?? '?'}, reset @ ${rl.reset ?? '?'}` : '';
      els.status.textContent = `${new Date(j.end_time).toLocaleString()} — ${rlStr}`;
      els.updated.textContent = 'Updated: ' + new Date().toLocaleTimeString();

      // Render sparkline (reuse your existing render function)
      renderSparkline(j?.per || []);

      // Adaptive schedule:
      // - If we still have quota, check again in 60s.
      // - If we're at 0 remaining, sleep until reset.
      if (rl && Number(rl.remaining) === 0 && rl.reset) {
        const resetEpoch = Number(rl.reset) * 1000;
        scheduleNext((resetEpoch - Date.now()) + 1500);
      } else {
        scheduleNext(60 * 1000);
      }
    } catch (e) {
      els.status.textContent = 'Network error.';
      scheduleNext(90 * 1000);
    }
  }

  // wire up UI (reuse your existing renderSparkline/etc.)
  els.go.addEventListener('click', fetchCounts);
  els.q.addEventListener('keydown', (e) => { if (e.key === 'Enter') fetchCounts(); });
  fetchCounts();
</script>
</body>
</html>
